---
title: "R Notebook"
output: html_notebook
---

```{r child="CleanLoad.Rmd"}
```


```{r}
# Select the variables checked in 01-startup.Rmd
varList <- c(LC_variable[LC_variable$inModel == TRUE, "variable_name"])$variable_name
varList <- c(varList, "grade_num", "sub_grade_num", "principal_loss_pct", "creditMargin", "monthDefault")

# Make sure that some variables are NOT in included in the training set
varRemove <- c("")
```


```{r}
#################################################################################################
##
## Prepare a dataset with ONLY the predictors
##
loansPredictors <-
  loansWorkingSet %>%

  # Keep the chosen predictors
  # Use one_of() to avoid errors if column does not exist
  select(one_of(varList)) %>%
  select(-one_of(varRemove)) %>%

  # [TODO] FOR THE MOMENT UNTIL MACRODATA IS FIXED
  #select(-one_of("addr_state")) %>%

  ##
  ## Dates to numeric, in 'decimal' years since 2000
  ##
  mutate_at(c("issue_d", "earliest_cr_line"), function(d) {
    return(year(d) - 2000 + (month(d) - 1) / 12)
  }) %>%

  ## Add polynomials of the dates to model the time-trend shape
  mutate(issue_d2 = issue_d ^ 2,
         issue_d3 = issue_d ^ 3,
         earliest_cr_line2 = earliest_cr_line ^ 2,
         earliest_cr_line3 = earliest_cr_line ^ 3) %>%

  # Fill missing values
  mutate_all(~replace(., is.na(.), 0))
```


```{r}
#################################################################################################
##
## One-hot encoding of factors (in case model do not mix continuous and cat. variables)
##
modelX <-
  loansPredictors %>%

  # Binary categories into 0/1
  mutate(disbursement_method = if_else(disbursement_method == "Cash", 1, 0)) %>%
  rename(cashDisbursement = disbursement_method) %>%

  mutate(application_type = if_else(application_type == "Individual", 0, 1)) %>%
  rename(applicationJoint = application_type) %>%

  ## Widen the categorical datas
  # Verification
  mutate(verifiedSource      = if_else(verification_status       == "Source Verified", 1, 0),
         verified            = if_else(verification_status       == "Not Verified", 0, 1),
         verifiedJointSource = if_else(verification_status_joint == "Source Verified", 1, 0),
         verifiedJoint       = if_else(verification_status_joint %in% c("", "Not Verified"), 0, 1)) %>%
  select(-verification_status, -verification_status_joint) %>%

  # Home ownership
  mutate(homeANY = if_else(home_ownership == "ANY", 1, 0),
         homeMORTGAGE = if_else(home_ownership == "MORTGAGE", 1, 0),

         # Delete beacuse useless
         homeNONE = if_else(home_ownership == "NONE", 1, 0),
         homeOTHER = if_else(home_ownership == "OTHER", 1, 0),
         homeOWN = if_else(home_ownership == "OWN", 1, 0),
         homeRENT = if_else(home_ownership == "RENT", 1, 0)) %>%
  select(-home_ownership) %>%

  # Purpose
  mutate(purpCAR = if_else(purpose == "car", 1, 0),
         purpCREDITCARD = if_else(purpose == "credit_card", 1, 0),
         purpCDEBTCONSO = if_else(purpose == "debt_consolidation", 1, 0),
         purpEDUCATION = if_else(purpose == "educational", 1, 0),
         purpHOMEIMPROV = if_else(purpose == "home_improvement", 1, 0),
         purpHOUSE = if_else(purpose == "house", 1, 0),
         purpPURCHASE = if_else(purpose == "major_purchase", 1, 0),
         purpMEDICAL = if_else(purpose == "medical", 1, 0),
         purpMOVING = if_else(purpose == "moving", 1, 0),
         purpOTHER = if_else(purpose == "other", 1, 0),
         purpRENEWABLE = if_else(purpose == "renewable_energy", 1, 0),
         purpSMALLBUS = if_else(purpose == "small_business", 1, 0),
         purpVACATION = if_else(purpose == "vacation", 1, 0),
         purpWEDDING = if_else(purpose == "wedding", 1, 0)) %>%
  select(-purpose)
```


```{r}
# Create training / test sets 80%/20%
proportionTraining <- 0.8
set.seed(42)
sampleTraining  <- sample(1:nSamples, floor(nSamples * proportionTraining), replace = FALSE)
loansTraining <- loansPredictors %>% slice( sampleTraining)
loansTest <-     loansPredictors %>% slice(-sampleTraining)
```


```{r}
modelTraining <- modelX %>% slice( sampleTraining)
modelTest <-     modelX %>% slice(-sampleTraining)
```


```{r}
# Subsets of the training set
set.seed(42)
nSamplesTraining <- nrow(loansTraining)
sample005 <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.005), replace = FALSE)
sample01  <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.01),  replace = FALSE)
sample05  <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.05),  replace = FALSE)
sample10  <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.10),  replace = FALSE)
sample20  <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.20),  replace = FALSE)

loans005 <- loansTraining %>% slice(sample005)
loans01  <- loansTraining %>% slice(sample01)
loans05  <- loansTraining %>% slice(sample05)
loans10  <- loansTraining %>% slice(sample10)
loans20  <- loansTraining %>% slice(sample20)

model005 <- modelX %>% slice(sampleTraining) %>% slice(sample005)
model01  <- modelX %>% slice(sampleTraining) %>% slice(sample01)
model05  <- modelX %>% slice(sampleTraining) %>% slice(sample05)
model10  <- modelX %>% slice(sampleTraining) %>% slice(sample10)
model20  <- modelX %>% slice(sampleTraining) %>% slice(sample20)

G005 <- modelX %>% select(sub_grade_num) %>% slice(sample005)
G01  <- modelX %>% select(sub_grade_num) %>% slice(sample01)
G05  <- modelX %>% select(sub_grade_num) %>% slice(sample05)
G10  <- modelX %>% select(sub_grade_num) %>% slice(sample10)
G20  <- modelX %>% select(sub_grade_num) %>% slice(sample20)

loss005 <- loansTraining %>% select(principal_loss_pct) %>% slice(sample005)
loss01  <- loansTraining %>% select(principal_loss_pct) %>% slice(sample01)
loss05  <- loansTraining %>% select(principal_loss_pct) %>% slice(sample05)
loss10  <- loansTraining %>% select(principal_loss_pct) %>% slice(sample10)
loss20  <- loansTraining %>% select(principal_loss_pct) %>% slice(sample20)

CM005  <- loansTraining %>% select(creditMargin) %>% slice(sample005)
CM01   <- loansTraining %>% select(creditMargin) %>% slice(sample01)
CM05   <- loansTraining %>% select(creditMargin) %>% slice(sample05)
CM10   <- loansTraining %>% select(creditMargin) %>% slice(sample10)
CM20   <- loansTraining %>% select(creditMargin) %>% slice(sample20)
```

$$
\begin{array}
\mathbf{PDF}(x) & = & \frac{1}{x \sigma \sqrt{2 \pi}} \exp{\left( - \frac{1}{2} 
{\left( \frac{\ln x - \mu}{\sigma} \right)}^2 \right)} \\
\mathbf{Mean} & = & \exp{ \left( \mu + \frac{\sigma^2}{2} \right) } \\
\mathbf{Mode} & = & \exp{ \left( \mu - \sigma^2 \right) } 
\end{array}
$$

$$
\begin{array}
\mathbf{PDF}(x) & = & \sqrt{\frac{e}{2 \pi}} \frac{1}{\left( x + m \right) \sigma}  exp{ \left( -\frac{1}2 \left( \frac{\log(\frac{x + m}{m}) - \sigma^2}  {\sigma} \right)^2 \right) } \\
\mathbf{Max} & = & \sqrt{\frac{e}{2 \pi}} \frac{1}{\left( 2 m \right) \sigma}  exp{ \left( -\frac{1}2 \left( \frac{\log(2) - \sigma^2}  {\sigma} \right)^2 \right) }
\end{array}
$$

# Calculate Loan principal schedule

```{r}
###################################################################################################
#
# Given some numerical parameters describing a loan in the dataset, returns its Internal Rate
# of Return.
#
# In the first instance, the function creates a schedule of payments.
# In many cases, the schedule will be extremely simple: a series of 36 or 60 equal instalements.
#
# But in some cases, a loan repayment are accelerated. Therefore the total amount of interest will
# be lower than expected (but this is good for the investor because highe interest rate over
# shorter tenor.).
#
# In other cases, the borrower defaults. Overall payments are less than expected.
#
# Based on the limited information of the dataset, the function makes educated guesses on the exact schedule.
#
# WARNING: THIS IS NOT OPTIMISED. RUNNING THIS FOR ALL LOANS (1.3 MLN OF THEM) TAKES CA.20 HOURS !!!!
#
loanSchedule <- function(loanNumber = 1,
                         loan = 1000,
                         intRate = 0.02,
                         term = 36,
                         totalPaid = 1000,
                         totalPrincipalPaid,
                         totalInterestPaid,
                         recoveries = 0,
                         lateFees = 0,
                         showSchedule = FALSE) {
  require(tidyverse)
  
  # number of monthly payments.
  # It exceeds 60 months in case recoveries on a 60-month loan takes the schedule after 60 months.
  nMonths <- 90
  
  # Months after which a loan defaults (normal tenor if no default or early prepayment)
  monthDefault = term
  
  # Note: *100 /100 to calculate in cent because ceiling cannot specify significant digits.
  installment <-
    ceiling(100 * loan * intRate / 12 / (1 - 1 / (1 + intRate / 12) ^ term)) / 100
  
  # We create a schedule
  schedule <- tibble(
    month = 0:nMonths,
    monthlyPayment = 0.0,
    principal = 0.0,
    interest = 0.0,
    totalPandI = 0.0,
    totalI = 0.0,
    totalP = 0.0
  )
  
  for (i in 2:(nMonths + 1)) {
    # Get situation at the end of previous month
    previousTotalPandI <- as.numeric(schedule[i - 1, "totalPandI"])
    previousTotalP     <- as.numeric(schedule[i - 1, "totalP"])
    previousTotalI     <- as.numeric(schedule[i - 1, "totalI"])
    
    # This is the beginning of a new month. First and foremost, the borrower is expected to pay the
    # accrued interest on amount of principal outstanding.
    # ceiling doesn't seem accept to accept significative digits.
    accruedInterest <-
      ceiling(100 * (loan - previousTotalP) * intRate / 12) / 100
    decreasePrincipal <- installment - accruedInterest
    
    
    # If that amount takes the schedule above the total amount of interest shown in the data set,
    # we should stop the schedule at this point
    if (previousTotalI + accruedInterest > totalInterestPaid) {
      # We stop the normal schedule at this date.
      # Interest is paid (although less than scheduled)
      schedule[i, "monthlyPayment"] <-
        totalInterestPaid - previousTotalI
      
      # As well as whatever principal is left as per the dataset
      schedule[i, "monthlyPayment"] <-
        schedule[i, "monthlyPayment"] + totalPrincipalPaid - previousTotalP
      
      # Then 3-month after the last payment date, recoveries and and late fees are paid
      schedule[i + 3, "monthlyPayment"] <-
        schedule[i + 3, "monthlyPayment"] + recoveries + lateFees
      
      
      schedule[i, "totalPandI"] <- totalPaid
      schedule[i, "totalI"]     <- totalInterestPaid
      schedule[i, "totalP"]     <- totalPrincipalPaid
      
      schedule[i, "interest"]   <-
        totalInterestPaid - previousTotalI
      schedule[i, "principal"]  <-
        totalPrincipalPaid - previousTotalP
      
      # If total principal paid is less than borrower, then it is a default, and the monthDefault
      # is adjusted.
      if (totalPrincipalPaid < loan) {
        monthDefault = i
      }
      
      # No more payments to add to the schedule
      break()
      
    } else {
      # Deal with normal schedule
      schedule[i, "monthlyPayment"] <- installment
      schedule[i, "totalPandI"] <-
        schedule[i - 1, "totalPandI"] + installment
      schedule[i, "totalI"]     <-
        schedule[i - 1, "totalI"]   + accruedInterest
      schedule[i, "totalP"]     <-
        schedule[i - 1, "totalP"]   + installment - accruedInterest
      
      schedule[i, "interest"]   <- accruedInterest
      schedule[i, "principal"]  <- decreasePrincipal
    }
  }
  
  # At this point schedule[, "monthlyPayment"] contains the schedule of all payments, but needs to
  # include the initial loan.
  schedule[1, "monthlyPayment"] <- -loan
  schedule[1, "principal"] <- -loan
  
  if (showSchedule) {
    schedule %>% view()
  }
  
  return(schedule)
}

library(tidyverse)
library(profvis)
profvis({
  # 50 ms/loan
  tictoc::tic()
  
  testloansSchedule <-
    loans %>%
    sample_n(1000) %>%
    rowwise() %>%
    do(
      loanSchedule(
        loanNumber = .$loanID,
        loan = .$funded_amnt,
        intRate = .$int_rate,
        term = .$term,
        totalPaid = .$total_pymnt,
        totalPrincipalPaid = .$total_rec_prncp,
        totalInterestPaid = .$total_rec_int,
        recoveries = .$recoveries,
        lateFees = .$total_rec_late_fee
      )
    )
  tictoc::toc()
})
```


#  NPV by purpose

```{r loss-distribution-purpose,fig.cap="Distribution of NPV (\\%) depending on rating \n(y-axis square-root scaling)"}

Set <- loansWorkingSet %>% 
  select(purpose, funded_amnt, total_rec_prncp) %>%
  filter(total_rec_prncp < funded_amnt - 1) %>% 
  mutate(PrincipalLoss = (funded_amnt - total_rec_prncp)/funded_amnt)

adjustSpread <- 1
rangeMin <- 0.0
rangeMax <- 1.5

Set %>% ggplot(aes(PrincipalLoss, col = purpose)) +
  geom_density(adjust = adjustSpread) +
  scale_x_continuous(limits = c(rangeMin, rangeMax)) +
  #scale_y_sqrt() + 
  xlab("")

```

#  NPV by state

```{r loss-distribution-state,fig.cap="Distribution of NPV (\\%) depending on rating \n(y-axis square-root scaling)"}

Set <- loansWorkingSet %>% 
  select(addr_state, funded_amnt, total_rec_prncp) %>%
  filter(total_rec_prncp < funded_amnt - 1) %>% 
  mutate(PrincipalLoss = (funded_amnt - total_rec_prncp)/funded_amnt)

adjustSpread <- 1
rangeMin <- 0.0
rangeMax <- 1.5

Set %>% ggplot(aes(PrincipalLoss, col = addr_state)) +
  geom_density(adjust = adjustSpread) +
  scale_x_continuous(limits = c(rangeMin, rangeMax)) +
  #scale_y_sqrt() + 
  xlab("")

```

#  NPV by employment length

```{r loss-distribution-emp,fig.cap="Distribution of NPV (\\%) depending on rating \n(y-axis square-root scaling)"}

Set <- loansWorkingSet %>% 
  select(emp_length, funded_amnt, total_rec_prncp) %>%
  mutate(emp_length = as.factor(ifelse(is.na(emp_length), 0, emp_length))) %>% 
  filter(total_rec_prncp < funded_amnt - 1) %>% 
  mutate(PrincipalLoss = (funded_amnt - total_rec_prncp)/funded_amnt)

adjustSpread <- 1
rangeMin <- 0.0
rangeMax <- 1.5

Set %>% ggplot(aes(PrincipalLoss, col = emp_length)) +
  geom_density(adjust = adjustSpread) +
  scale_x_continuous(limits = c(rangeMin, rangeMax)) +
  #scale_y_sqrt() + 
  xlab("")

```

#  NPV by home ownership

```{r loss-distribution-home,fig.cap="Distribution of NPV (\\%) depending on rating \n(y-axis square-root scaling)"}

Set <- loansWorkingSet %>% 
  select(home_ownership, funded_amnt, total_rec_prncp) %>%
  filter(total_rec_prncp < funded_amnt - 1) %>% 
  mutate(PrincipalLoss = (funded_amnt - total_rec_prncp)/funded_amnt)

adjustSpread <- 1
rangeMin <- 0.0
rangeMax <- 1.5

Set %>% ggplot(aes(PrincipalLoss, col = home_ownership)) +
  geom_density(adjust = adjustSpread) +
  scale_x_continuous(limits = c(rangeMin, rangeMax)) +
  #scale_y_sqrt() + 
  xlab("")


```

# Information value (no package)

```{r}
Set <- loansWorkingSet %>%
  mutate(goodLoan = (abs(funded_amnt - total_rec_prncp) < 1), 
         badLoan  = !goodLoan)

nGood = Set %>% filter(goodLoan == TRUE) %>% nrow()
nBad  = Set %>% filter(badLoan  == TRUE) %>% nrow()
```

## Home ownership

```{r}
CountGB <- Set %>% 
  mutate(goodLoan = as.factor(goodLoan)) %>% 
  group_by(home_ownership, goodLoan) %>% 
  mutate(totalByDefault = n()) %>% 
  ungroup() %>% 
  
  mutate(gg = if_else(goodLoan == "TRUE",  totalByDefault / nGood, 0), 
         bb = if_else(goodLoan == "FALSE", totalByDefault / nBad , 0)) %>% 
  
  group_by(home_ownership) %>% 
  summarise(gg = max(gg), 
            bb = max(bb)) %>% 
  mutate(IV = (gg - bb) * log(gg / bb)) 

sum(CountGB$IV)
```


## State

```{r}
CountGB <- Set %>% 
  mutate(goodLoan = as.factor(goodLoan)) %>% 
  group_by(addr_state, goodLoan) %>% 
  mutate(totalByDefault = n()) %>% 
  ungroup() %>% 
  
  mutate(gg = if_else(goodLoan == "TRUE",  totalByDefault / nGood, 0), 
         bb = if_else(goodLoan == "FALSE", totalByDefault / nBad , 0)) %>% 
  
  group_by(addr_state) %>% 
  summarise(gg = max(gg), 
            bb = max(bb)) %>% 
  mutate(IV = (gg - bb) * log(gg / bb)) 

sum(CountGB$IV)
```


## Verification status

```{r}
CountGB <- Set %>% 
  mutate(goodLoan = as.factor(goodLoan)) %>% 
  group_by(verification_status, goodLoan) %>% 
  mutate(totalByDefault = n()) %>% 
  ungroup() %>% 
  
  mutate(gg = if_else(goodLoan == "TRUE",  totalByDefault / nGood, 0), 
         bb = if_else(goodLoan == "FALSE", totalByDefault / nBad , 0)) %>% 
  
  group_by(verification_status) %>% 
  summarise(gg = max(gg), 
            bb = max(bb)) %>% 
  mutate(IV = (gg - bb) * log(gg / bb)) 

sum(CountGB$IV)
```

## Application type

```{r}
CountGB <- Set %>% 
  mutate(goodLoan = as.factor(goodLoan)) %>% 
  group_by(application_type, goodLoan) %>% 
  mutate(totalByDefault = n()) %>% 
  ungroup() %>% 
  
  mutate(gg = if_else(goodLoan == "TRUE",  totalByDefault / nGood, 0), 
         bb = if_else(goodLoan == "FALSE", totalByDefault / nBad , 0)) %>% 
  
  group_by(application_type) %>% 
  summarise(gg = max(gg), 
            bb = max(bb)) %>% 
  mutate(IV = (gg - bb) * log(gg / bb)) 

sum(CountGB$IV)
```

## Grade

```{r}
CountGB <- Set %>% 
  mutate(goodLoan = as.factor(goodLoan)) %>% 
  group_by(grade, goodLoan) %>% 
  mutate(totalByDefault = n()) %>% 
  ungroup() %>% 
  
  mutate(gg = if_else(goodLoan == "TRUE",  totalByDefault / nGood, 0), 
         bb = if_else(goodLoan == "FALSE", totalByDefault / nBad , 0)) %>% 
  
  group_by(grade) %>% 
  summarise(gg = max(gg), 
            bb = max(bb)) %>% 
  mutate(IV = (gg - bb) * log(gg / bb)) 

sum(CountGB$IV)
```

## Sub-grade

```{r}
CountGB <- Set %>% 
  mutate(goodLoan = as.factor(goodLoan)) %>% 
  group_by(sub_grade, goodLoan) %>% 
  mutate(totalByDefault = n()) %>% 
  ungroup() %>% 
  
  mutate(gg = if_else(goodLoan == "TRUE",  totalByDefault / nGood, 0), 
         bb = if_else(goodLoan == "FALSE", totalByDefault / nBad , 0)) %>% 
  
  group_by(sub_grade) %>% 
  summarise(gg = max(gg), 
            bb = max(bb)) %>% 
  mutate(IV = (gg - bb) * log(gg / bb)) 

sum(CountGB$IV)
```

## Debt to income

```{r}
CountGB <- Set %>% 
  mutate(goodLoan = as.factor(goodLoan)) %>% 
  filter(!is.na(dti)) %>% 
  mutate(dti = as_factor(dti)) %>% 
  group_by(dti, goodLoan) %>% 
  mutate(totalByDefault = n()) %>% 
  ungroup() %>% 
  
  mutate(gg = if_else(goodLoan == "TRUE",  totalByDefault / nGood, 0), 
         bb = if_else(goodLoan == "FALSE", totalByDefault / nBad , 0)) %>% 
  
  group_by(dti) %>% 
  summarise(gg = max(gg), 
            bb = max(bb)) %>% 
  mutate(IV = (gg - bb) * log(gg / bb)) %>% 
  filter(is.finite(IV))

sum(CountGB$IV)

```



## Loop through all variables

```{r}
loansBinning <- loansWorkingSet %>%
  mutate(home_ownership = as_factor(home_ownership)) %>%
  mutate(
    emp_length = as_factor(emp_length),
    goodLoan = (abs(funded_amnt - total_rec_prncp) < 1),
    badLoan  = !goodLoan
  ) %>%
  as.data.frame()

nGood = loansBinning %>% filter(goodLoan == TRUE) %>% nrow()
nBad  = loansBinning %>% filter(badLoan  == TRUE) %>% nrow()


listIV <- tibble(field = names(loansBinning), IV = -1.0)

for (n in listIV$field) {
  cat("Variable: ", n)
  
  if (n == "isDefault") {
    cat("\n")
  } else {
    if (is.factor(loansBinning[, n])) {
      cat(" is a factor, ")
      
      v <- as.character(n)
      
      CountGB <- loansBinning %>%
        select(goodLoan, badLoan, !!v) %>%
        filter(!is.na(!!v)) %>%
        group_by(!!sym(v), goodLoan) %>%
        mutate(totalByDefault = n()) %>%
        ungroup() %>%
        
        mutate(
          gg = if_else(goodLoan == "TRUE",  totalByDefault / nGood, 0),
          bb = if_else(goodLoan == "FALSE", totalByDefault / nBad , 0)
        ) %>%
        
        group_by(!!sym(v)) %>%
        summarise(gg = max(gg),
                  bb = max(bb)) %>%
        mutate(IV = (gg - bb) * log(gg / bb)) %>%
        filter(is.finite(IV))
      
      
      
      resultHome <- sum(CountGB$IV)
      
      
      tryCatch({
        cat("     IV = ", resultHome)
        listIV[which(listIV[, "field"] == n)  , "IV"] <- resultHome
      },
      error = function(e) {
        return(NA)
      })
    }
    
    cat("\n")
  }
}

```



# NPV distributions

##  NPV by verification status

```{r loss-distribution-verification,fig.cap="Distribution of NPV (\\%) depending on rating \n(y-axis square-root scaling)"}

Set <- loansWorkingSet %>% 
  select(verification_status, funded_amnt, total_rec_prncp) %>%
  filter(total_rec_prncp < funded_amnt - 1) %>% 
  mutate(PrincipalLoss = (funded_amnt - total_rec_prncp)/funded_amnt)

adjustSpread <- 1
rangeMin <- 0.0
rangeMax <- 1.5

Set %>% ggplot(aes(PrincipalLoss, col = verification_status)) +
  geom_density(adjust = adjustSpread) +
  scale_x_continuous(limits = c(rangeMin, rangeMax)) +
  #scale_y_sqrt() + 
  xlab("")

```


##  NPV by application type

```{r loss-distribution-joint,fig.cap="Distribution of NPV (\\%) depending on rating \n(y-axis square-root scaling)"}

Set <- loansWorkingSet %>% 
  select(application_type, funded_amnt, total_rec_prncp) %>%
  filter(total_rec_prncp < funded_amnt - 1) %>% 
  mutate(PrincipalLoss = (funded_amnt - total_rec_prncp)/funded_amnt)

adjustSpread <- 1
rangeMin <- 0.0
rangeMax <- 1.5

Set %>% ggplot(aes(PrincipalLoss, col = application_type)) +
  geom_density(adjust = adjustSpread) +
  scale_x_continuous(limits = c(rangeMin, rangeMax)) +
  #scale_y_sqrt() + 
  xlab("")

```


# K-Means

```{r eval=FALSE}
library(cluster)
library(factoextra)
library(caret)

trainKMEANS <- train(
  x = model01,
  y = Y01$sub_grade_num,
  method = "knn",
  tuneGrid = data.frame(k = seq(3, 9, 2))
)

# Random Search
# set.seed(seed)
# rf_random <- train(Class~., data = dataset, method = "rf", metric = metric, trControl = control)
# print(rf_random)
# plot(rf_random)


###################################################################################################
##
## RANDOM FOREST
##
## Use Rborist since it accepts factors
##


# 17000 sec.
# Best result = 32 predictors
```


```{r eval=FALSE}
{
  tictoc::tic()
  
  require(caret)
  require(Rborist)
  require(doParallel)
  
  cl <- makePSOCKcluster(4)
  registerDoParallel(cl)
  
  loansTmp <- loans005 %>% select(-creditMargin, principal_loss_pct)
  trainRF <- train(
    x = loansTmp,
    y = CM005$creditMargin,
    method = "Rborist",
    nSamp = 2500,
    trControl = trainControl(method = "cv")
  )
  
  stopCluster(cl)
  tictoc::toc()
  
  print(trainRF)
  varImp(trainRF)
}

#################################################################################################
# Random Forest
#
# IF RESPONSE IS THE SUB-GRADE
#
# 13063 samples
# 63 predictor
#
# No pre-processing
# Resampling: Cross-Validated (10 fold, repeated 1 times)
# Summary of sample sizes: 11756, 11757, 11757, 11757, 11758, 11757, ...
# Resampling results across tuning parameters:
#
#   predFixed  RMSE       Rsquared   MAE
# 2         1.0217915  0.4787036  0.8070386
# 32         0.9217696  0.4984839  0.7231087
# 63         0.9235622  0.4944814  0.7241667
#
# Tuning parameter 'minNode' was held constant at a value of 3
# RMSE was used to select the optimal model using the smallest value.
# The final values used for the model were predFixed = 32 and minNode = 3.
#

#################################################################################################
# Random Forest
#
# IF RESPONSE IS THE PRINCIPAL LOSS (in %)
#
# 13063 samples
# 65 predictor
#
# No pre-processing
# Resampling: Cross-Validated (10 fold)
# Summary of sample sizes: 11756, 11757, 11757, 11758, 11756, 11756, ...
# Resampling results across tuning parameters:
#
#   predFixed  RMSE       Rsquared    MAE
# 2         0.2824622  0.09468031  0.2166095
# 33         0.2812666  0.09767208  0.2120904
# 65         0.2820000  0.09485043  0.2124572
#
# Tuning parameter 'minNode' was held constant at a value of 3
# RMSE was used to select the optimal model using the smallest value.
# The final values used for the model were predFixed = 33 and minNode = 3.
#
#
#################################################################################################
# Random Forest
#
# IF RESPONSE IS THE CREDIT MARGIN (in %)
# BUT: principal loss and credit margins were in the predictors
#
#
# 10450 samples
# 73 predictor
#
# No pre-processing
# Resampling: Cross-Validated (10 fold)
# Summary of sample sizes: 9404, 9405, 9405, 9405, 9405, 9405, ...
# Resampling results across tuning parameters:
#
#   predFixed  RMSE        Rsquared   MAE
# 2         0.38465362  0.7490979  0.189267621
# 37         0.04906856  0.9926129  0.013818872
# 73         0.01188224  0.9995688  0.001378399
#
# Tuning parameter 'minNode' was held constant at a value of 3
# RMSE was used to select the optimal model using the smallest value.
# The final values used for the model were predFixed = 73 and minNode = 3.
#
# 6642 sec.
#



# .
# Best result = 32 predictors



#################################################################################################
#
# 8008.441 sec elapsed
#
# Random Forest
#
# ON
#
# loansTmp <- loans005 %>% select(-creditMargin, principal_loss_pct)
# trainRF <- train(x = loansTmp, y = CM005$creditMargin,
#                  method = "Rborist",
#                  nSamp = 2500,
#                  trControl = trainControl(method = "cv"))
#
#
# 5225 samples
# 72 predictor
#
# No pre-processing
# Resampling: Cross-Validated (10 fold)
# Summary of sample sizes: 4704, 4702, 4704, 4702, 4701, 4703, ...
# Resampling results across tuning parameters:
#
#   predFixed  RMSE       Rsquared   MAE
# 2         0.4449010  0.4494987  0.21419547
# 37         0.1864721  0.8824442  0.09965741
# 72         0.1688334  0.9004621  0.09087179
#
# Tuning parameter 'minNode' was held constant at a value of 3
# RMSE was used to select the optimal model using the smallest value.
# The final values used for the model were predFixed = 72 and minNode = 3.
# Rborist variable importance
#
# only 20 most important variables shown (out of 72)
#
# Overall
# percent_bc_gt_75           100.0000
# term                         4.0345
# total_il_high_credit_limit   0.6672
# mo_sin_old_il_acct           0.5140
# pub_rec_bankruptcies         0.5113
# tax_liens                    0.4631
# num_tl_120dpd_2m             0.3957
# int_rate                     0.3929
# loan_amnt                    0.3790
# sub_grade_num                0.3747
# principal_loss_pct           0.3612
# open_rv_12m                  0.3385
# num_bc_tl                    0.3336
# avg_cur_bal                  0.2823
# acc_now_delinq               0.2798
# total_acc                    0.2701
# loanID                       0.2673
# inq_last_6mths               0.2381
# verification_status_joint    0.2249
# tot_hi_cred_lim              0.2033
# Warning message:
#   Setting row names on a tibble is deprecated.



# 17000 sec.
# Best result = 32 predictors
```

## Extreme boosting

```{r eval=FALSE}
{
  tictoc::tic()
  
  require(caret)
  require(xgboost)
  require(doParallel)
  
  cl <- makePSOCKcluster(4)
  registerDoParallel(cl)
  
  loansTmp <-
    model005 %>% select(-creditMargin, principal_loss_pct, monthDefault)
  trainXGB <- train(
    x = loansTmp,
    y = CM005$creditMargin,
    method = "xgbTree",
    preProcess = "pca",
    trControl = trainControl(method = "cv")
  )
  
  stopCluster(cl)
  tictoc::toc()
  
  #confusionMatrix(predict(trainXGB, val_test_data[, -1]), val_test_data$outcome)
  
  print(trainXGB)
  varImp(trainXGB)
}
```


```{r eval=FALSE}
{
  require(caret)
  require(Rborist)
  require(doParallel)
  
  cl <- makePSOCKcluster(4)
  registerDoParallel(cl)
  
  tictoc::tic()
  
  trainRF <- train(
    x = loans01,
    y = Y01$sub_grade_num,
    method = "Rborist",
    predFixed = 32,
    nSamp = 2500
  )
  
  tictoc::toc()
  stopCluster(cl)
  
  print(trainRF)
}



ggplot(trainRF)

cc <- cor(modelX)
ggcorrplot::ggcorrplot(cc, hc.order = TRUE, type = "upper", outline.color = "white")



tmp01 <-
  loans %>%
  slice(sample01) %>%
  select(funded_amnt, int_rate, installment, term, total_pymnt, total_rec_prncp)

```


# Optimised binning for Information Value

## Data preparation

```{r child="CleanLoad.Rmd"}
```

```{r}
rm(lending_club)
```


```{r}
# Select the variables checked in 01-startup.Rmd
varList <- c(LC_variable[LC_variable$inModel == TRUE, "variable_name"])$variable_name
varList <- c(varList, "grade_num", "sub_grade_num", "principal_loss_pct", "creditMargin", "monthDefault")

# Make sure that some variables are NOT in included in the training set
varRemove <- c("")
```


```{r}
#################################################################################################
##
## Prepare a dataset with ONLY the predictors NOT removing NA's
##
loansPredictors <-
  loansWorkingSet %>%

  # Keep the chosen predictors
  # Use one_of() to avoid errors if column does not exist
  select(one_of(varList)) %>%
  select(-one_of(varRemove)) %>%

  # [TODO] FOR THE MOMENT UNTIL MACRODATA IS FIXED
  # select(-one_of("addr_state")) %>%

  ##
  ## Dates to numeric, in 'decimal' years since 2000
  ##
  mutate_at(c("issue_d", "earliest_cr_line"), function(d) {
    return(year(d) - 2000 + (month(d) - 1) / 12)
  }) %>%

  ## Add polynomials of the dates to model the time-trend shape
  mutate(issue_d2 = issue_d ^ 2,
         issue_d3 = issue_d ^ 3,
         earliest_cr_line2 = earliest_cr_line ^ 2,
         earliest_cr_line3 = earliest_cr_line ^ 3) %>% 
  
  ## Create default flag as int as required by `smbinning`
  mutate(isDefault = if_else(principal_loss_pct >= 0.001, 1, 0))


#################################################################################################
##
## Create training / test sets 80%/20%
##
proportionTraining <- 0.8
set.seed(42)
sampleTraining  <- sample(1:nSamples, floor(nSamples * proportionTraining), replace = FALSE)
loansTraining <- loansPredictors %>% slice( sampleTraining)
loansTest <-     loansPredictors %>% slice(-sampleTraining)

# Subsets of the training set
set.seed(42)
nSamplesTraining <- nrow(loansTraining)
sample005 <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.005), replace = FALSE)
sample01  <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.01),  replace = FALSE)
sample05  <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.05),  replace = FALSE)
sample10  <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.10),  replace = FALSE)
sample20  <- sample(1:nSamplesTraining,  floor(nSamplesTraining * 0.20),  replace = FALSE)

loans005 <- loansTraining %>% slice(sample005)
loans01  <- loansTraining %>% slice(sample01)
loans05  <- loansTraining %>% slice(sample05)
loans10  <- loansTraining %>% slice(sample10)
loans20  <- loansTraining %>% slice(sample20)

loss005 <- loansTraining %>% select(principal_loss_pct) %>% slice(sample005)
loss01  <- loansTraining %>% select(principal_loss_pct) %>% slice(sample01)
loss05  <- loansTraining %>% select(principal_loss_pct) %>% slice(sample05)
loss10  <- loansTraining %>% select(principal_loss_pct) %>% slice(sample10)
loss20  <- loansTraining %>% select(principal_loss_pct) %>% slice(sample20)

```

## Binning

```{r}
detach("package:scorer", unload = TRUE, force = TRUE)
devtools::install_local("~/Development/R/DVPT-PACKAGES/Score_modeling_binning/scorer", force = TRUE, quiet = TRUE)
#devtools::install_github("Emmanuel-R8/SMBinning")
library(scorer)
```

```{r}
loansBinning <- loans10 %>% 
  mutate(home_ownership = as_factor(home_ownership),
         emp_length = as_factor(emp_length), 
         isDefaultBool = (isDefault == 1)) 

```

### dti

```{r}
resultHome <- binTableContinuous(
  df = loansBinning, 
  x = "dti",
  y = "isDefault",
  p = 0.05)

resultHome$table
resultHome$IV

```

### Home ownership

```{r}
resultHome <- binTableCategorical(
  df = loansBinning, 
  x = "home_ownership", 
  y = "isDefaultBool", 
  maxCategories = 20)

resultHome
resultHome$IV

```

### Verification Status

```{r}
resultVerif <- binTableCategorical(
  df = loansBinning, 
  x = "verification_status", 
  y = "isDefaultBool", 
  maxCategories = 20)

resultVerif
resultVerif$IV

```



### Purpose

```{r}
resultHome <- binTableCategorical(
  df = loansBinning, 
  x = "purpose", 
  y = "isDefaultBool", 
  maxCategories = 20)

resultHome
resultHome$IV

```


### Sub grade

```{r}
resultSubgrade <- binTableCategorical(
  df = loansBinning, 
  x = "sub_grade", 
  y = "isDefaultBool", 
  maxCategories = 50)

resultSubgrade
resultSubgrade$IV

```



### Employment years

```{r}
resultEmp <- binTableCategorical(
  df = loansBinning, 
  x = "emp_length", 
  y = "isDefaultBool", 
  maxCategories = 20)

resultEmp
resultEmp$IV

```



### Bank card utilisation

```{r}
resultBC <- binTableContinuous(
  df = loansBinning, 
  x = "bc_util", 
  y = "isDefault", 
  p = 0.05)

resultBC
resultBC$IV

```



### State

```{r}
resultState <- binTableCategorical(
  df = loansBinning, 
  x = "addr_state", 
  y = "isDefaultBool", 
  maxCategories = 100)

resultState
resultState$IV

```


### Annual income

```{r}
which(names(loansBinning) == "annual_inc_joint")

resultInc <- binTableContinuous(
  df = loansBinning, 
  x = "annual_inc_joint", 
  y = "isDefault", 
  p = 0.05)

resultHome
resultHome$iv

```

### Loan amount

```{r}
resultAmnt <- binTableContinuous(
  df = loansBinning, 
  x = "loan_amnt", 
  y = "isDefault", 
  p = 0.05)

resultAmnt$IV

```

### Credit Margin

```{r}
resultCM <- binTableContinuous(
  df = loansBinning, 
  x = "creditMargin", 
  y = "isDefault", 
  p = 0.05)

resultCM$IV
resultCM
```


## Loop through all variables

```{r}
detach("package:scorer", unload = TRUE, force = TRUE)
devtools::install_local("~/Development/R/DVPT-PACKAGES/Score_modeling_binning/scorer", force = TRUE, quiet = TRUE)
#devtools::install_github("Emmanuel-R8/SMBinning")
library(scorer)
```


```{r}

loansBinning <- loans20 %>%
  mutate(home_ownership = as_factor(home_ownership),
         emp_length = as_factor(emp_length),
         grade = as_factor(grade), 
         isDefaultBool = (isDefault == 1)) 


listIV <- tibble(field = names(loansBinning), IV = -1.0)
listBins <- list()

for (n in listIV$field) {
  cat("Field: ", n)
  
  if (n %in% c("isDefault", "isDefaultBool")) {
    cat("\n")
  } else {
    if (class(loansBinning[[1, n]]) == "factor") {
      cat(" is a factor, ")
      result <- binTableCategorical(df = loansBinning,
        x = n,
        y = "isDefaultBool",
        maxCategories = 100
      )
    } else {
      cat(" is numeric, ")
      result <- binTableContinuous(df = loansBinning,
                              x = n,
                              y = "isDefault",
                              p = 0.05)
    }
    
    tryCatch({
      cat("     IV = ", result$IV)
      listIV[which(listIV[,"field"] == n)  , "IV"] <- result$IV
      listBins <- c(listBins, list(result))
    }, 
    error = function(e) {
      return(NA)
  } )
    
    cat("\n")
  }
}


```

```{r}
#saveRDS(listIV, "datasets/listIV005.rds")
#saveRDS(listBins, "datasets/listBins005.rds")
#saveRDS(listIV, "datasets/listIV020.rds")
```


Ignore the variables that would not be available before the credit scoring is complete.

```{r}
bestBins <- listIV %>% 
  filter(!(field %in% c("loanID", "term", "int_rate", "creditMargin", "loan_status", 
                        "grade", "sub_grade", "grade_num", "sub_grade_num", 
                        "emp_length", "home_ownership", "monthDefault"))) %>% 
  filter(IV >= 0.02) %>% 
  arrange(desc(IV))


bestBins
```





## Model training

```{r}
detach("package:smbinning", unload = TRUE, force = TRUE)
#devtools::install_github("Emmanuel-R8/SMBinning")
devtools::install_local(path = "~/Development/R/DVPT-PACKAGES/Score_modeling_binning/smbinning", force = TRUE)
library(smbinning)

loansBinning <- loans005 %>%
  sample_n(250) %>% 
  mutate(home_ownership = as_factor(home_ownership)) %>% 
  select(-loanID) %>% 
  as.data.frame()

smbinning.logitrank(df = loansBinning,
                    y = "isDefault",  
                    chr = as_vector(bestBins[,1]))

```





```{r}
## https://blog.revolutionanalytics.com/2015/03/r-package-smbinning-optimal-binning-for-scoring-modeling.html
data("smbsimdf1")
resultSmbinning <- smbinning(smbsimdf1, y = "fgood", x = "tob", p = 0.05)

resultSmbinning$ivtable

```
```{r}
# Relevant plots (2x2 Page)
par(mfrow = c(2, 2))

boxplot(
  smbsimdf1$tob ~ smbsimdf1$fgood,
  horizontal = T,
  frame = F,
  col = "lightgray",
  main = "Distribution"
)

mtext("Time on Books (Months)", 3)

smbinning.plot(resultSmbinning, option = "dist", sub = "Time on Books (Months)")
smbinning.plot(resultSmbinning, option = "badrate", sub = "Time on Books (Months)")
smbinning.plot(resultSmbinning, option = "WoE", sub = "Time on Books (Months)")

```



